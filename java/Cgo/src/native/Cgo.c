// To makes this particular type of code more readable this file intentionally
// only follows some of the Google C++ style guide.
//
// More specifically, the changes are:
//  - the signatures are copied verbatim from the Cgo.h generated by javah
//  - the start curly bracket for the functions sits on its own line
//  - if guards have the code block on the same line with the if
//  - some lines are longer than 80 characters.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "golib.h"
#include "Cgo.h"

static JavaVM *jvm = NULL;

static int init(JNIEnv *env)
{
    if (jvm == NULL) {
        return (*env)->GetJavaVM(env, &jvm);
    }
    return 0;
}

static JNIEnv *get_jni_env(JNIEnv *env)
{
    if (env != NULL) {
        return env;
    }
    JNIEnv *result;
    int error = (*jvm)->AttachCurrentThread(jvm, (void **)&result, NULL);
    if (error < 0) {
        // TODO(razvanm): throw an exception.
        fprintf(stderr, "AttachCurrentThread error: %d\n", error);
    }
    return result;
}

/*
 * Class:     Cgo
 * Method:    add
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_Cgo_add
  (JNIEnv *env, jclass cls, jint a, jint b)
{
    return x_Add(a, b);
}

/*
 * Class:     Cgo
 * Method:    addAndSub
 * Signature: (II)LCgo/AddAndSubResult;
 */
JNIEXPORT jobject JNICALL Java_Cgo_addAndSub__II
  (JNIEnv *env, jclass cls, jint a, jint b)
{
    jclass result_class;
    jmethodID cid;
    jobject result;
    jfieldID add_id;
    jfieldID sub_id;

    struct x_AddAndSub_return go_result = x_AddAndSub(a, b);

    result_class = (*env)->FindClass(env, "Cgo$AddAndSubResult");
    if (result_class == NULL) { return NULL; }

    cid = (*env)->GetMethodID(env, result_class, "<init>", "()V");
    if (cid == NULL) { return NULL; }

    result = (*env)->NewObject(env, result_class, cid);
    if (result == NULL) { return NULL; }

    add_id = (*env)->GetFieldID(env, result_class, "add", "I");
    if (add_id == NULL) { return NULL; }
    (*env)->SetIntField(env, result, add_id, go_result.r0);

    sub_id = (*env)->GetFieldID(env, result_class, "sub", "I");
    if (sub_id == NULL) { return NULL; }
    (*env)->SetIntField(env, result, sub_id, go_result.r1);

    (*env)->DeleteLocalRef(env, result_class);

    return result;
}

/*
 * The '00024' was added manually because of [1].
 *
 * [1] https://bugs.openjdk.java.net/browse/JDK-8145897
 *
 * Class:     Cgo
 * Method:    addAndSub
 * Signature: (IILCgo$AddAndSubResult;)V
 */
JNIEXPORT void JNICALL Java_Cgo_addAndSub__IILCgo_00024AddAndSubResult_2
  (JNIEnv *env , jclass cls, jint a, jint b, jobject result)
{
    int add_result;
    int sub_result;
    jclass result_class;
    jfieldID add_id;
    jfieldID sub_id;

    x_AddAndSubPtrs(a, b, &add_result, &sub_result);

    result_class = (*env)->FindClass(env, "Cgo$AddAndSubResult");
    if (result_class == NULL) { return; }

    add_id = (*env)->GetFieldID(env, result_class, "add", "I");
    if (add_id == NULL) { return; }
    (*env)->SetIntField(env, result, add_id, add_result);

    sub_id = (*env)->GetFieldID(env, result_class, "sub", "I");
    if (sub_id == NULL) { return; }
    (*env)->SetIntField(env, result, sub_id, sub_result);

    (*env)->DeleteLocalRef(env, result_class);
}

/*
 * Class:     Cgo
 * Method:    div
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_Cgo_div
  (JNIEnv *env, jclass cls, jint a, jint b)
 {
    struct x_Div_return div_result = x_Div(a, b);

    if (div_result.r1.id.n != 0) {
        jclass exception_cls = (*env)->FindClass(env, "java/lang/ArithmeticException");
        if (cls != NULL) {
            // TODO(razvanm): Who owns the div_result.r1.msg.p pointer?
            (*env)->ThrowNew(env, exception_cls, div_result.r1.msg.p);
        }
        (*env)->DeleteLocalRef(env, exception_cls);
    }

    return div_result.r0;
}

/*
 * Class:     Cgo
 * Method:    divPtrs
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_Cgo_divPtrs
  (JNIEnv *env, jclass cls, jint a, jint b)
{
    int result;
    x_VError error;

    error.id.n = 0;
    x_DivPtrs(a, b, &result, &error);

    if (error.id.n != 0) {
        jclass exception_cls = (*env)->FindClass(env, "java/lang/ArithmeticException");
        if (cls != NULL) {
            // TODO(razvanm): Who owns the div_result.r1.msg.p pointer?
            (*env)->ThrowNew(env, exception_cls, error.msg.p);
        }
        (*env)->DeleteLocalRef(env, exception_cls);
    }

    return result;
}

/*
 * Class:     Cgo
 * Method:    sqrt
 * Signature: (D)D
 */
JNIEXPORT jdouble JNICALL Java_Cgo_sqrt
  (JNIEnv *env, jclass cls, jdouble value)
{
    return x_Sqrt(value);
}

/*
 * Class:     Cgo
 * Method:    echo
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_Cgo_echo
  (JNIEnv *env, jclass cls, jstring text)
{
    x_String xs_arg;
    x_String xs_result;

    xs_arg.n = (*env)->GetStringUTFLength(env, text);
    xs_arg.p = malloc(xs_arg.n);
    if (xs_arg.p == NULL) { return NULL; }
    (*env)->GetStringUTFRegion(env, text, 0, xs_arg.n, (char *)xs_arg.p);

    // XEcho takes ownership of the xs_arg.p pointer.
    x_Echo(xs_arg, &xs_result);

    return (*env)->NewStringUTF(env, xs_result.p);
}

/*
 * Class:     Cgo
 * Method:    echoFoo
 * Signature: (LCgo/Foo;)LCgo/Foo;
 */
JNIEXPORT jobject JNICALL Java_Cgo_echoFoo
  (JNIEnv *env, jclass cls, jobject obj)
{
    jclass foo_class;
    jobject foo_str;
    jobject foo_arr;
    x_Foo foo_arg;
    x_Foo foo_result;
    x_VError error;
    jfieldID foo_str_id;
    jfieldID foo_arr_id;
    jfieldID foo_num_id;
    jmethodID cid;
    jobject result;
    jbyteArray arr;

    foo_class = (*env)->FindClass(env, "Cgo$Foo");
    if (foo_class == NULL) { return NULL; }

    foo_str_id = (*env)->GetFieldID(env, foo_class, "str", "Ljava/lang/String;");
    if (foo_str_id == NULL) { return NULL; }
    foo_arr_id = (*env)->GetFieldID(env, foo_class, "arr", "[B");
    if (foo_arr_id == NULL) { return NULL; }
    foo_num_id = (*env)->GetFieldID(env, foo_class, "num", "I");
    if (foo_num_id == NULL) { return NULL; }

    foo_str = (*env)->GetObjectField(env, obj, foo_str_id);
    foo_arg.str.n = (*env)->GetStringUTFLength(env, foo_str);
    foo_arg.str.p = malloc(foo_arg.str.n);
    if (foo_arg.str.p == NULL) { return NULL; }
    (*env)->GetStringUTFRegion(env, foo_str, 0, foo_arg.str.n, (char *)foo_arg.str.p);

    foo_arr = (*env)->GetObjectField(env, obj, foo_arr_id);
    foo_arg.arr.n = (*env)->GetArrayLength(env, foo_arr);
    foo_arg.arr.p = malloc(foo_arg.arr.n);
    if (foo_arg.arr.p == NULL) { return NULL; }
    (*env)->GetByteArrayRegion(env, foo_arr, 0, foo_arg.arr.n, (jbyte *)foo_arg.arr.p);

    foo_arg.num = (*env)->GetIntField(env, obj, foo_num_id);

    error.id.n = 0;
    x_EchoFoo(foo_arg, &foo_result, &error);
    if (error.id.n != 0) {
        // Raise exception?
    }

    cid = (*env)->GetMethodID(env, foo_class, "<init>", "()V");
    if (cid == NULL) { return NULL; }

    result = (*env)->NewObject(env, foo_class, cid);
    if (result == NULL) { return NULL; }

    (*env)->SetObjectField(env, result, foo_str_id, (*env)->NewStringUTF(env, foo_result.str.p));

    arr = (*env)->NewByteArray(env, foo_result.arr.n);
    (*env)->SetByteArrayRegion(env, arr, 0, foo_result.arr.n, (const jbyte *)foo_result.arr.p);
    (*env)->SetObjectField(env, result, foo_arr_id, arr);

    (*env)->SetIntField(env, result, foo_num_id, foo_result.num);

    (*env)->DeleteLocalRef(env, foo_class);

    return result;
}

typedef struct {
    JNIEnv *env;
    jobject obj;
    jmethodID method;
    // If free is non-zero then int_callback will deallocate the pointer to
    // IntCallbackArgs.
    int free;
} IntCallbackArgs;

void int_callback(x_Handle xhandle, int value)
{
    IntCallbackArgs *args = (IntCallbackArgs *)xhandle;
    JNIEnv *env = get_jni_env(args->env);
    (*env)->CallVoidMethod(env, args->obj, args->method, value);
    if (args->free) {
        free((void *)xhandle);
    }
}

/*
 * The '00024' was added manually because of [1].
 *
 * [1] https://bugs.openjdk.java.net/browse/JDK-8145897
 *
 * Class:     Cgo
 * Method:    streamInts
 * Signature: (ILCgo$IntCallback;)V
 */
JNIEXPORT void JNICALL Java_Cgo_streamInts__ILCgo_00024IntCallback_2
  (JNIEnv *env, jclass cls, jint x, jobject callback)
{
    jclass callback_class;
    jmethodID on_value_id;

    callback_class = (*env)->FindClass(env, "Cgo$IntCallback");
    if (callback_class == NULL) { return; }

    on_value_id = (*env)->GetMethodID(env, callback_class, "onValue", "(I)V");
    if (on_value_id == NULL) { return; }

    // The args can sit on the stack because the XStreamInts will block while
    // xcallback is in use.
    IntCallbackArgs args = {env, callback, on_value_id, 0 /* free */};
    x_IntCallback xcallback = {(long)&args, int_callback};
    x_StreamInts(x, xcallback);
}

typedef struct {
    jobject obj;
    jmethodID method;
} DoneCallbackArgs;

void done_callback(x_Handle xhandle_value, x_Handle xhandle_done)
{
    DoneCallbackArgs *args = (DoneCallbackArgs *)xhandle_done;
    JNIEnv *env = get_jni_env(NULL);
    (*env)->CallVoidMethod(env, args->obj, args->method);
    (*env)->DeleteGlobalRef(env, args->obj);
    free((void *)xhandle_value);
    free((void *)xhandle_done);
}

/*
 * The '00024' was added manually because of [1].
 *
 * [1] https://bugs.openjdk.java.net/browse/JDK-8145897
 *
 * Class:     Cgo
 * Method:    streamInts
 * Signature: (ILCgo$IntStreamCallbacks;)V
 */
JNIEXPORT void JNICALL Java_Cgo_streamInts__ILCgo_00024IntStreamCallbacks_2
  (JNIEnv *env, jclass cls, jint x, jobject callbacks)
{
    jclass callbacks_class;
    jmethodID on_value_id;
    jmethodID on_done_id;

    callbacks_class = (*env)->FindClass(env, "Cgo$IntStreamCallbacks");
    if (callbacks_class == NULL) { return; }

    on_value_id = (*env)->GetMethodID(env, callbacks_class, "onValue", "(I)V");
    if (on_value_id == NULL) { return; }

    on_done_id = (*env)->GetMethodID(env, callbacks_class, "onDone", "()V");
    if (on_done_id == NULL) { return; }

    IntCallbackArgs *on_value_args = malloc(sizeof(IntCallbackArgs));
    if (on_value_args == NULL) { return; }
    on_value_args->env = NULL;
    on_value_args->obj = (*env)->NewGlobalRef(env, callbacks);
    on_value_args->method = on_value_id;
    on_value_args->free = 0;  // done_callback will do call free.

    DoneCallbackArgs *on_done_args = malloc(sizeof(DoneCallbackArgs));
    if (on_value_args == NULL) { return; }
    on_done_args->obj = (*env)->NewGlobalRef(env, callbacks);
    on_done_args->method = on_done_id;

    if (init(env) != 0) { return; }

    x_StreamCallbacks xcallbacks = {
        (long)on_value_args, (long)on_done_args, int_callback, done_callback
    };
    x_AsyncStreamInts(x, xcallbacks);
}

/*
 * Class:     Cgo
 * Method:    addAsync
 * Signature: (IILCgo$IntCallback;)V
 */
JNIEXPORT void JNICALL Java_Cgo_addAsync
  (JNIEnv *env, jclass cls, jint a, jint b, jobject callback)
{
    jclass callback_class;
    jmethodID on_value_id;

    callback_class = (*env)->FindClass(env, "Cgo$IntCallback");
    if (callback_class == NULL) { return; }

    on_value_id = (*env)->GetMethodID(env, callback_class, "onValue", "(I)V");
    if (on_value_id == NULL) { return; }

    IntCallbackArgs *args = malloc(sizeof(IntCallbackArgs));
    if (args == NULL) { return; }
    args->env = NULL;
    args->obj = (*env)->NewGlobalRef(env, callback);
    args->method = on_value_id;
    args->free = 1;

    if (init(env) != 0) { return; }

    x_IntCallback xcallback = {(long)args, int_callback};
    x_AsyncAdd(a, b, xcallback);
}
